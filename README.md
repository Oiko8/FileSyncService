# hw1-Oiko8
- ΟΝΟΜΑΤΕΠΩΝΥΜΟ: ΓΙΑΝΝΗΣ ΟΙΚΟΝΟΜΙΔΗΣ
- Α.Μ.: 1115201600120

# ΠΕΡΙΓΡΑΦΗ ΤΟΥ PROJECT 

Το παρόν project υλοποιεί ένα File Synchronization Service (FSS) σε C γλώσσα σε περιβάλλον UNIX, χρησιμοποιώντας κλήσεις συστήματος χαμηλού επιπέδου για τη διαχείριση αρχείων και το bash scripting και χρήση named pipes για επικοινωνία μεταξύ των διεργασιών. Το σύστημα διασφαλίζει την δημιουργία αντιγράφων από έναν φάκελο πηγή σε έναν φάκελο προορισμό, επιτρέπει στον χρήστη να παρέμβει ή να ενημερωθεί για τους συγχρονισμούς μέσω εντολών που δίνει στην κονσόλα και με χρήση των συναρτήσεων inotify παρακολουθεί τις εξελίξεις των υπό επεξεργασία φακέλων. 




# ΠΛΑΝΟ ΥΛΟΠΟΙΗΣΗΣ ΤΟΥ PROJECT

Κάνοντας τον αρχικό προγραμματισμό, το project βασίστηκε σε 4 βασικά προγράμματα:
1. fss_manager.c : η υλοποίηση ξεκίνησε από αυτό καθώς είναι ο πυρήνας του όλου συστήματος. Συνεργάζεται άμεσα με τα άλλα δύο βασικά προγράμματα που θα περιγραφούν παρακάτω, fss_console.c και worker_process.c. Έχει τρεις βασικές λειτουργίες, οι οποίες επιτυγχάνονται με την βοήθεια άλλων συμπληρωματικών λειτουργιών που θα αναλυθούν παρακάτω και οι οποίες είναι η εξής: 
	1. Διαβάζει το config_file, το οποίο θεωρούμε ότι αποτελείται από ζεύγη φακέλων σε κάθε γραμμή και το πρώτο αποτελεί την πηγή και το δεύτερο τον προορισμό. Ο manager καλείται να συγχρονίσει πλήρως τους δύο φακέλους και να τους εντάξει στην δομή που κρατάει για παρακολούθησει.
	2. Παρακολουθεί συνεχώς μέσω inotify τους φακέλους πηγές που έχουν προστεθεί στην δομή δεδομένων που κρατάει και για όποια αλλαγή παρατηρηθεί(CREATE, MODIFY, DELETE) στα αρχεία του φακέλου πηγή, φροντίζει να συγχρονίσει άμεσα τον φάκελο προορισμό.
	3. Δημιουργεί δύο FIFOs (named pipes) μέσω των οποίων επικοινωνεί με τον console, από τον οποίο δέχεται κάποιες εντολές (add, cancel, status, sync, shutdown) και για κάθε μία φροντίζει να εκτελέσει τις αντίστοιχες λειτουργίες, όπως θα περιγραφούν στον fss_console.c .


2. worker_process.c : η διεργασία αυτή εκτελείται από τον manager με τη χρήση κλήσεων συστήματος της οικογένειας exec() και της fork() και φροντίζει για τον συγχρονισμό των αρχείων. Δέχεται σαν ορίσματα το ζεύγος των φακέλων που καλείται να συγχρονίσει καθώς και τον τύπο του συγχρονισμού που πρέπει να εκτελέσει. Οι επιλογές είναι οι εξής:
	1. ADDED: προσθέτει απλά το αρχείο που δέχτηκε σαν όρισμα στον προορισμό(δεδομένο είναι ότι υπάρχει στην πηγή λόγω τελευταίων αλλαγών).
	2. MODIFIED: αντιγράφει εκ νέου το αρχείο που δέχτηκε σαν όρισμα στον προορισμό και κρατάει την νέα εκδοχή(δεδομένο ότι το αρχείο τροποποιήθηκε στην πηγή)
	3. DELETED: διαγράφει στον προορισμό το αρχείο που δέχτηκε σαν όρισμα το οποίο προηγουμένως διαγράφτηκε και στον φάκελο πηγή(ώστε να είναι συγχρονισμένοι και πάλι).
	4. FULL: αντιγράφει εκ νέου όλο το περιεχόμενο του φακέλου πηγή στον προορισμό(φροντίζει ο προορισμός να είναι άδειος ώστε εν τέλει να είναι πλήρως συγχρονισμένοι οι δύο φάκελοι.

[ σημείωση: είναι φανερό ότι όσον αφορά το config_file και τις εντολές από τον console(add,sync) ο worker καλείται να εκτελέσει FULL συγχρονισμό. Οι άλλες επιλογές(ADDED,MODIFIED,DELETED) αφορούν αλλαγές που εντοπίστηκαν σε μεμονομένα αρχεία των καταλόγων που παρακολουθούνται μέσω inotify ]


3. fss_console.c : ουσιαστικά αποτελεί μία διεπαφή με τον χρήστη ο οποίος μπόρει να δώσει εντολές μέσω αυτού, οι οποίες θα εκτελεστούν από τον manager. Ο console επικοινωνεί με τον manager χρησιμοποιώντας τα named pipes, στέλνει σε αυτόν τις εντολές που του υπαγορεύει ο χρήστης και δέχεται πίσω ένα ενημερωτικό μήνυμα για την ολοκλήρωση των απαραίτητων εργασιών ή αναλόγα για τα όποια προβλήματα παρουσιάστηκαν. Οι εντολές που επιτρέπονται στον χρήστη είναι οι εξής:
	1. add source target: με αυτήν την εντολή ο manager προσθέτει στην δομή με τους καταλόγους το ζεύγος source-target για παρακολούθηση και εκκινεί πλήρη συγχρονισμό μεταξύ των δύο.
	2. cancel source: με αυτήν την εντολή ο manager σταματάει την παρακολούθηση για τον κατάλογο source και τον διαγράφει από την δομή δεδομένων του (θεωρείται δεδομένο ότι κάθε source επιτρέπεται να έχει μοναδικό target και όχι πολλαπλά)
	3. status source: τυπώνεται ένα ενημερωτικό μήνυμα για την κατάσταση του καταλόγου source. Περιλαμβάνει ημερομηνία τελευταίου συγχρονισμού, πόσα λάθη έγιναν και αν ο φάκελος είναι ενεργός.
	4. sync source target: ο manager εκκινεί πλήρη συγχρονισμό μεταξύ των δύο φακέλων source-target άσχετα με το αν είναι πλήρως συγχρονισμένη ή όχι.
	5. shutdown: δεχόμενος αυτήν την εντολή ο manager φροντίζει να τελειώσει όλες τις εργασίες σε εκκρεμότητα και στην συνέχεια τερματίζει. Ομοίως τερματίζει και ο console.


4. fss_script.sh: πρόκειται για ένα bash script το οποίο δέχεται σαν παράμετρο ένα path (σε ένα logfile ή σε έναν κατάλογο) και μία εντολή. Οι εντολές που δέχεται είναι οι εξής:
	1. listAll : Αναζητά στο log-file (path) και εμφανίζει όλους τους καταλόγους, την ημερομηνία και ώρα τελευταίου συγχρονισμού, μαζί με status (Success, Error, Partial).
	2. purge : Διαγράφει το αρχείο/κατάλογο που βρίσκεται στο path, είτε το path αναφέρεται σε ένα logfile ή σε έναν κατάλογο.
 




# ΔΟΜΗ ΑΡΧΕΙΩΝ

Τα συνολικά αρχεία που χρησιμοποιήθηκαν στο project είναι τα εξής:
1. fss_manager.c
2. worker_process.c
3. fss_console.c
4. fss_script.sh
5. Makefile
6. queue_implementation.c
7. queue_implementation.h
8. sync_info_mem_store.c
9. sync_info_mem_store.h





# ΑΝΑΛΥΤΙΚΉ ΠΕΡΙΓΡΑΦΉ ΤΩΝ ΑΡΧΕΙΩΝ ΚΑΙ ΕΠΙΣΗΜΑΝΣΗ ΤΩΝ ΣΗΜΑΝΤΙΚΩΝ ΣΥΝΑΡΤΗΣΕΩΝ

1. fss_manager.c: λειτουργίες των σημαντικών συναρτήσεων του αρχείου:
	1. int main(int argc, char* argv[]) : 	
		- δημιουργία και άνοιγμα named pipes.
		- κλήση συνάρτησεις για το διάβασμα του config_file και για το συγχρονισμό του. 
		- εκκίνηση βρόγχο μέσα στον οποίο εκτελεί τις βασικές του λειτουργίες μέχρι να λάβει σήμα για τερματισμό από τον console.
		- μέσα στον βρόγχο ελέγχει ένα ένα τα directories που παρακολουθούνται ώστε σε περίπτωση που ανιχνευθεί κάποια αλλαγή να καλέσει τη συνάρτηση call_worker() η οποία εκτελεί των συγχρονισμό αρχείων.
		- μέσα στον βρόγχο διαβάζει τις εντολές που στέλνονται από τον console μέσω του named pipe "fss_in" και για κάθε μία εκτελεί τις απαραίτητες εργασίες. Ενημερώνει τον console μεσω του named pipe "fss_out" για την εξέλιξη και την ολοκλήρωση των εντολών.
		- φροντίζει να εκτελούνται μέχρι ένα συγκεκριμένο πλήθος εργασιών συγχρονισμού ταυτόχρονα και οι υπόλοιπες να μπαίνουν σε ουρά αναμονής. Πριν το τέλος του βρόχου ελέγχει αν υπάρχουν αναμένουσες εντολές και αν μπορούν να εκτελεστούν με βάση τους διαθέσιμους workers.
		- πριν τερματίσει, κλείνει τους named pipes, διαγράφει τους file descriptors και ελευθερώνει την λίστα με τα directories που παρακολουθούνται.

	2. void read_config_file(const char*, const char*, int) : 
		- ανοίγει το config file και αρχίζει να διαβάζει τα ζεύγη source-target που υπάρχουν σε κάθε γραμμή.
		- αν μια γραμμή δεν έχει το επιθυμητό format (source target) ενημερώνει με μήνυμα στην κονσόλα, ότι υπάρχει invalid entry.
		- κλήση συνάρτησης call_worker για κάθε γραμμή που περιέχει ζεύγος source-target.
	
	3. void call_worker(char* ,char* ,char* ,char* ,const char*, int) :
		- τα ορίσματα που δέχεται αναπαριστούν μια εντολή. Τα πρώτα δύο ορίσματα αφορούν τα source-target directories, το επόμενο το file που μας αφορά(ALL αν μας αφορούν όλα) και το τέταρτο την λειτουργία που πρέπει να εκτελέσουμε (FULL, ADD, MODIFIED, DELETED). 
		- έλεγχος αν οι workers που εκτελούνται ξεπερνούν το επιθυμητό όριο. Αν ναι η εντολή μπαίνει σε σειρά αναμονής
		- προσθήκη του source καταλόγου για παρακολούθηση σε περίπτωση που δεν παρακολουθείται ήδη.
		- άνοιγμα pipes για επικοινωνία μεταξύ manager και worker_process.c.
		- κλήση συστήματος της fork(), ώστε μέσω της διεργασίας παιδί να εκτελέσει τη διεργασία worker_process.c με την χρήση exec().
		- αναμονή για τερματισμό του παιδιού από τον parent και ενημέρωση από το report που έστειλε το παιδί μέσω του pipe.
		- ενημέρωση του manager_log_file μέσω της void update_logfile_file(char*, const char*) για το πως ολοκληρώθηκε η εργασία. Η ενημέρωση είναι της μορφής: 
[2025-04-27 18:13:45] [source] [target] [4181] [FULL] [SUCCESS] [3 files copied, 0 failed].


2. worker_process.c: λειτουργίες των σημαντικών συναρτήσεων του αρχείου:
	1. int main(int argc, char *argv[]):
		- με βάση τα ορίσματα αποσπά πληροφορίες για: τα path για τους καταλόγους source-target, το όνομα του αρχείου που θα πρέπει να επεξεργαστεί (FULL αν αφορά όλα τα αρχεία) και το την λειτουργία που πρέπει να εκτελέσει(FULL, ADDED, MODIFIED, DELETED).
		- το source επιβάλλεται να υπάρχει ήδη, το target δημιουργείται σε περίπτωση που δεν υπάρχει.
		- εκτέλεση ενεργειών με βάση την κάθε λειτουργία.
		- κλείσιμο των ανοιχτών καταλόγων
		- κλήση report(), η οποία στέλνει μέσω pipe στον manager την ενημέρωση σχετικά με την διεκπεραίωση της εντολής που ζητήθηκε.
	2. void report(char*, char*,const char*, int, int, const char* ):
		- αποστολή ενημερωτικού μηνύματος πίσω στον manager μέσω pipe.
	3. int copy_files(char*, char*):
		- αντιγραφή του ή των αρχείου/ων από την πηγή στον προορισμό.
	4. void clean_directory(char*):
		- διαγραφή όλου του περιεχομένου του καταλόγου που στάλθηκε σαν όρισμα. 


3. fss_console.c: λειτουργίες των σημαντικών συναρτήσεων του αρχείου:
	1. int main(int argc, char *argv[]):
		- άνοιγμα των named pipes και ενημέρωση ότι το σύστημα τέθηκε σε λειτουργία τη στιγμή που θα ανοίξει και ο manager.
		- διάβασμα της εντολής από την κονσόλα και ενημέρωση του manager για αυτήν μέσω του named pipe "fss_in".
		- ενημέρωση του logfile για την νέα εντολή του χρήστη. Μορφή εγγραφής στο logfile: [2025-04-26 15:59:57] Command add source -> target.
		- διάβασμα της ενημέρωσης του manager για την εξέλιξη της εντολής μέσω του named pipe "fss_out".
	2. void handle_sigint(int sig):
		- σε περίπτωση απρόσμενου τερματισμού του console στέλνει μήνυμα στον manager να τερματίσει.


4. sync_info_mem_store.c: αποτελεί την δομή που χρησιμοποιεί ο manager για να κρατήσει τις απαραίτητες πληροφορίες για τους καταλόγους που συγχρονίζονται και παρακολουθούνται. Η δομή είναι μια linked list που αποθηκεύει items της μορφης:
typedef struct{
    char source_dir[PATH_LENGTH];
    char target_dir[PATH_LENGTH];
    int active;
    time_t last_sync_time;
    int error_count;
    int is_syncing;
    int fd_watch;
    int watch_d;
} syncInfo;
Περιέχει πλήθος συναρτήσεων για την επεξεργασία της λίστας, των item της λίστας και των πεδίων των item της λίστας. Χρησιμοποιείται το αρχείο sync_info_mem_store.h με την δήλωση των συναρτήσεων και των struct που χρησιμοποιούνται ως διεπαφή με τα υπόλοιπα προγράμματα.


5. queue_implementation.c: αποτελεί την ουρά στην οποία αποθηκεύονται οι εντολές που πρέπει να τεθούν σε αναμονή μέχρι να αδειάσει κάποιος worker. Αποθηκεύει item της μορφής:
typedef struct {
    // keeping the infos we need to run a command
    char source[PATH_LENGTH];
    char target[PATH_LENGTH];
    char filename[PATH_LENGTH]; 
    char operation[16];         
} commandItem;
Στα πεδία αποθηκεύονται οι πληροφορίες που χρειάζονται για να καλεστεί η διεργασία worker_process.c αργότερα και να εκτελέσει την εντολή. Το αρχείο περιέχει συναρτήσεις για την προσθήκη εντολής στην ουρά, εξαγωγή και διαγραφή εντολής από την ουρά και έλεγχο για την περίπτωση που η ουρά είναι άδεια. Χρησιμοποιείται το αρχείο queue_implementation.h με την δήλωση των συναρτήσεων και των struct που χρησιμοποιούνται ως διεπαφή με τα υπόλοιπα προγράμματα. 

  

# ΟΔΗΓΙΕΣ ΕΚΤΕΛΕΣΗΣ

1. Compilation:
	- make : δημιουργία αντικείμενων και εκτελέσιμων αρχείων.
	- make clean : διαγραφή των αντικείμενων και εκτελέσιμων αρχείων.

2. Εκτέλεση:
	- ο manager τρέχει με την εντολή : ./fss_manager -l <manager_log_file> -c <config_file> -n WORKER_LIMIT
	- ο console τρέχει με την εντολή : ./fss_console -l <console_log_file> 	
	- το bash script εκτελείται ως εξής: 
		α.  ./fss_script.sh -p <logfile> -c listAll : εκτυπώνει την τελευταία ενημέρωση από όλους τους καταλόγους που παρακολουθήθηκαν και γράφτηκαν στο <logfile>.
		β.  ./fss_script.sh -p <logfile> -c purge : διαγράφει το περιεχόμενο του <logfile>
		γ.  ./fss_script.sh -p <directory> -c purge : αδειάζει το <directory>. Χρησιμοποιείται για να αδειάζουν τα target directories μετά τους συγχρονισμό τους με τα source.
	
3. Σημαντική σημείωση: ο manager πρέπει να τρέξει πρώτος για να δημιουργήσει τα named pipes ώστε να τρέξει και ο console. Προτείνεται τα δύο αρχεία να τρέxουν ταυτόχρονα. Ο manager είναι λειτουργικός και χωρίς τον console καθώς κάνει συγχρονισμό των καταλόγων του config_file και ανοίγει τα named pipes ως NON_BLOCKING ώστε να λειτουργεί και χωρίς να ανοίξει το άλλο άκρο. Ο console φυσικά μπλοκάρει και περιμένει να ανοίξει και ο manager για να τεθεί σε λειτουργία. Για λόγους ευχρηστίας και αποφυγής προβλημάτων ο console ελέγχει πότε θα κλείσει ο manager, οπότε σε περίπτωση απρόσμενου τερματισμού του console θα σταλεί "shutdown" στο manager και θα τερματίσει ομαλά κλείνοντας τα απαραίτητα ανοιχτά κανάλια.



# ΠΑΡΑΤΗΡΗΣΕΙΣ 
- O worker_process.c στέλνει την exec_report του στην μορφή που θα τυπωθεί στο log_file του manager για λόγους ευχρηστίας και για να μην επιβαρυνθεί ο manager επιπλέον με την επεξεργασία του μηνύματος.
- O manager τυπώνει στην οθόνη την ενημέρωση που γράφει στο log_file και ως έξτρα για καθαρότητα των εκτυπώσεων από ποιον worker είναι η ενημέρωση και επίσης ενημερώνει σε περίπτωση που ανιχνεύθηκε inotify_event και το εκτυπώνει πριν λάβει δράση για αυτό.
- Οι κατάλογοι θεωρείται ότι περιέχουν μόνο αρχεία και όχι άλλους κατολόγους.
- Ένα directory μπορεί να εισαχθεί μόνο μία φορά σαν source δηλαδή μπορεί να έχει μόνο ένα target. Αν θέλουμε να κάνουμε συγχρονισμό ενός source με άλλο target πρέπει να το κάνουμε cancel και ξανά add με το νέο target.
- ένα source που είναι ενεργό και παρακολουθείται, μπορεί να χρησιμοποιηθεί ως target σε ένα άλλο ζεύγος που θα γίνει add. Τότε το inotify θα ενημερώσει για τις αλλαγές του αρχικού source και θα κάνει εκ νέου συγχρονισμούς. Π.χ. 
add source1 target1
add source2 source1
Μόλις γίνει ο δεύτερος συγχρονισμός, θα γίνουν αλλαγές στο source1 οι οποίες θα ανιχνευθούν από το inotify καθώς το source1 παρακολουθείται.   
- Ο console ενημερώνει τον χρήστη για οποιοδήποτε λάθος στις εντολές που δέχεται.
- Η εντολή sync απαιτεί και το source και το directory, για μεγαλύτερη ασφάλεια ότι ο χρηστής θα εκτελέσει τον συγχρονισμό που θέλει και για έξτρα δυνατότητα να συγχρονιστεί ένα source με διαφορετικό target από αυτό που έχει γίνει add. Παράδειγμα:
add /home/source1 /home/backup1  -> θα εκτελεστεί.
add /home/source1 /home/backup2  -> δε θα εκτελεστεί και ο χρήστης θα ενημερωθεί ότι ο κατάλογος ήδη παρακολουθείται.
sync /home/source1 /home/backup2 -> θα εκτελεστεί κανονικά, ώστε ο χρήστης να μπορεί να κάνει έξτρα συγχρονισμούς χειροκίνητα.
- Δεν υλοποιήθηκαν listMonitored και listStopped εντολές για το bash script γιατί θα απαιτούσαν σημαντικές αλλαγές της αρχιτεκτονικής.

